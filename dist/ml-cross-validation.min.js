!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((t=t||self).mlCrossValidation={})}(this,function(t){"use strict";class e{constructor(t,e){if(t.length!==t[0].length)throw new Error("Confusion matrix must be square");if(e.length!==t.length)throw new Error("Confusion matrix and labels should have the same length");this.labels=e,this.matrix=t}static fromLabels(t,n){let r,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(n.length!==t.length)throw new Error("predicted and actual must have the same length");r=i.labels?new Set(i.labels):new Set([...t,...n]),r=Array.from(r),i.sort&&r.sort(i.sort);const s=Array.from({length:r.length});for(let t=0;t<s.length;t++)s[t]=new Array(s.length),s[t].fill(0);for(let e=0;e<n.length;e++){const i=r.indexOf(t[e]),o=r.indexOf(n[e]);i>=0&&o>=0&&s[i][o]++}return new e(s,r)}getMatrix(){return this.matrix}getLabels(){return this.labels}getTotalCount(){let t=0;for(let e=0;e<this.matrix.length;e++)for(let n=0;n<this.matrix.length;n++)t+=this.matrix[e][n];return t}getTrueCount(){let t=0;for(let e=0;e<this.matrix.length;e++)t+=this.matrix[e][e];return t}getFalseCount(){return this.getTotalCount()-this.getTrueCount()}getTruePositiveCount(t){const e=this.getIndex(t);return this.matrix[e][e]}getTrueNegativeCount(t){const e=this.getIndex(t);let n=0;for(let t=0;t<this.matrix.length;t++)for(let r=0;r<this.matrix.length;r++)t!==e&&r!==e&&(n+=this.matrix[t][r]);return n}getFalsePositiveCount(t){const e=this.getIndex(t);let n=0;for(let t=0;t<this.matrix.length;t++)t!==e&&(n+=this.matrix[t][e]);return n}getFalseNegativeCount(t){const e=this.getIndex(t);let n=0;for(let t=0;t<this.matrix.length;t++)t!==e&&(n+=this.matrix[e][t]);return n}getPositiveCount(t){return this.getTruePositiveCount(t)+this.getFalseNegativeCount(t)}getNegativeCount(t){return this.getTrueNegativeCount(t)+this.getFalsePositiveCount(t)}getIndex(t){const e=this.labels.indexOf(t);if(-1===e)throw new Error("The label does not exist");return e}getTruePositiveRate(t){return this.getTruePositiveCount(t)/this.getPositiveCount(t)}getTrueNegativeRate(t){return this.getTrueNegativeCount(t)/this.getNegativeCount(t)}getPositivePredictiveValue(t){const e=this.getTruePositiveCount(t);return e/(e+this.getFalsePositiveCount(t))}getNegativePredictiveValue(t){const e=this.getTrueNegativeCount(t);return e/(e+this.getFalseNegativeCount(t))}getFalseNegativeRate(t){return 1-this.getTruePositiveRate(t)}getFalsePositiveRate(t){return 1-this.getTrueNegativeRate(t)}getFalseDiscoveryRate(t){const e=this.getFalsePositiveCount(t);return e/(e+this.getTruePositiveCount(t))}getFalseOmissionRate(t){const e=this.getFalseNegativeCount(t);return e/(e+this.getTruePositiveCount(t))}getF1Score(t){const e=this.getTruePositiveCount(t);return 2*e/(2*e+this.getFalsePositiveCount(t)+this.getFalseNegativeCount(t))}getMatthewsCorrelationCoefficient(t){const e=this.getTruePositiveCount(t),n=this.getTrueNegativeCount(t),r=this.getFalsePositiveCount(t),i=this.getFalseNegativeCount(t);return(e*n-r*i)/Math.sqrt((e+r)*(e+i)*(n+r)*(n+i))}getInformedness(t){return this.getTruePositiveRate(t)+this.getTrueNegativeRate(t)-1}getMarkedness(t){return this.getPositivePredictiveValue(t)+this.getNegativePredictiveValue(t)-1}getConfusionTable(t){return[[this.getTruePositiveCount(t),this.getFalseNegativeCount(t)],[this.getFalsePositiveCount(t),this.getTrueNegativeCount(t)]]}getAccuracy(){let t=0,e=0;for(let n=0;n<this.matrix.length;n++)for(let r=0;r<this.matrix.length;r++)n===r?t+=this.matrix[n][r]:e+=this.matrix[n][r];return t/(t+e)}getCount(t,e){const n=this.getIndex(t),r=this.getIndex(e);return this.matrix[n][r]}get accuracy(){return this.getAccuracy()}get total(){return this.getTotalCount()}}const n={mode:"index"};var r=function*(t,e,r){r=Object.assign({},n,r);for(var i,s,o,a=new Array(e),l=new Array(t),u=new Array(e),h=new Array(e+2),g=0;g<e;g++)a[g]=g,u[g]=g<e-t?0:1;for(g=0;g<t;g++)l[g]=e-t+g;for(g=0;g<h.length;g++)h[g]=0===g?e+1:g<=e-t?0:g<=e?g-e+t:-2;function f(){var t,e,n;for(e=1;h[e]<=0;)e++;if(0===h[e-1]){for(t=e-1;1!==t;t--)h[t]=-1;h[e]=0,i=o=0,h[1]=1,s=e-1}else{e>1&&(h[e-1]=0);do{e++}while(h[e]>0);for(n=e-1,t=e;0===h[t];)h[t++]=-1;if(-1===h[t])h[t]=h[n],o=h[n]-1,i=t-1,s=n-1,h[n]=-1;else{if(t===h[0])return 0;h[e]=h[t],o=h[t]-1,h[t]=0,i=e-1,s=t-1}}return 1}if("index"===r.mode)for(yield l.slice();f();)l[o]=a[i],yield l.slice();else{if("mask"!==r.mode)throw new Error("Invalid mode");for(yield u.slice();f();)u[i]=1,u[s]=0,yield u.slice()}};function i(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:5,n=t.length,r=new Array(n);for(let t=0;t<n;t++)r[t]=t;let i=Math.floor(n/e),s=[],o=[];for(;r.length;){let t=Math.floor(Math.random()*r.length);s.push(r[t]),r.splice(t,1),s.length===i&&(o.push(s),s=[])}return s.length&&s.forEach(t=>o[e-1].push(t)),(o=o.slice(0,e)).map((t,e)=>({testIndex:t,trainIndex:[].concat(...o.filter((t,n)=>n!==e))}))}function s(t,n,i,s,g){let f;"function"==typeof s&&(f=s,g=i,i=n,n=t),o(n,i);const c=l(i),d=a(c.length,c.length);let v=n.length,m=r(g,v),x=new Array(v);for(let t=0;t<v;t++)x[t]=t;for(const e of m){let r=x.slice();for(let t=e.length-1;t>=0;t--)r.splice(e[t],1);f?h(n,i,e,r,d,c,f):u(t,n,i,s,e,r,d,c)}return new e(d,c)}function o(t,e){if(t.length!==e.length)throw new Error("features and labels should have the same length")}function a(t,e){return new Array(t).fill(0).map(()=>new Array(e).fill(0))}function l(t){let e=new Set;for(let n=0;n<t.length;n++)e.add(t[n]);return Array.from(e)}function u(t,e,n,r,i,s,o,a){const{testFeatures:l,trainFeatures:u,testLabels:h,trainLabels:c}=f(e,n,i,s);let d;t.prototype.train?(d=new t(r)).train(u,c):d=new t(u,c,r),g(o,h,d.predict(l),a)}function h(t,e,n,r,i,s,o){const{testFeatures:a,trainFeatures:l,testLabels:u,trainLabels:h}=f(t,e,n,r);g(i,u,o(l,h,a),s)}function g(t,e,n,r){for(let i=0;i<n.length;i++){const s=r.indexOf(e[i]),o=r.indexOf(n[i]);(s<0||o<0)&&console.warn("ignore unknown predicted label ".concat(n[i])),t[s][o]++}}function f(t,e,n,r){return{testFeatures:n.map(function(e){return t[e]}),trainFeatures:r.map(function(e){return t[e]}),testLabels:n.map(function(t){return e[t]}),trainLabels:r.map(function(t){return e[t]})}}t.getFolds=i,t.getTrainTest=f,t.kFold=function(t,n,r,s,g){let f;"function"==typeof s&&(f=s,g=r,r=n,n=t),o(n,r);const c=l(r),d=a(c.length,c.length);let v=i(n,g);for(let e=0;e<v.length;e++){let i=v[e].testIndex,o=v[e].trainIndex;f?h(n,r,i,o,d,c,f):u(t,n,r,s,i,o,d,c)}return new e(d,c)},t.leaveOneOut=function(t,e,n,r){if("function"==typeof n){let r=n;return n=e,s(e=t,n,1,r)}return s(t,e,n,r,1)},t.leavePOut=s,t.sampleAClass=function(t,e){let n=JSON.parse(JSON.stringify(t)),r=Array.from(Array(n.length).keys()).sort((t,e)=>n[t]<n[e]?-1:n[e]<n[t]|0);n.sort((t,e)=>t<e?-1:e<t|0);let i={};n.forEach(t=>i[t]=(i[t]||0)+1);let s=[];Object.keys(i).forEach((t,n)=>{let r=[];Object.values(i).reduce((t,e,n)=>r[n]=t+e,0);let o=[...Array(i[t]).keys()],a=[];for(let n=0;n<Math.floor(i[t]*e);n++){let t=o[Math.floor(Math.random()*o.length)];a.push(t);let e=o.indexOf(t);o.splice(e,1)}s=0===n?s.concat(a):s.concat(a.map(t=>t+r[n-1]))});let o=[];s.forEach(t=>o.push(r[t]));let a=[],l=[];return t.forEach((t,e)=>{o.includes(e)?l.push(!0):(l.push(!1),a.push(e))}),{trainIndex:o,testIndex:a,mask:l}},Object.defineProperty(t,"__esModule",{value:!0})});
//# sourceMappingURL=ml-cross-validation.min.js.map
