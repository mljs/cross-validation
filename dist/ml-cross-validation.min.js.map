{"version":3,"file":"ml-cross-validation.min.js","sources":["../node_modules/ml-confusion-matrix/src/index.js","../node_modules/ml-combinations/src/index.js","../src/getFolds.js","../src/index.js","../src/sampleAClass.js"],"sourcesContent":["/**\n *  Constructs a confusion matrix\n * @class ConfusionMatrix\n * @example\n * const CM = new ConfusionMatrix([[13, 2], [10, 5]], ['cat', 'dog'])\n * @param {Array<Array<number>>} matrix - The confusion matrix, a 2D Array. Rows represent the actual label and columns\n *     the predicted label.\n * @param {Array<any>} labels - Labels of the confusion matrix, a 1D Array\n */\nexport default class ConfusionMatrix {\n  constructor(matrix, labels) {\n    if (matrix.length !== matrix[0].length) {\n      throw new Error('Confusion matrix must be square');\n    }\n    if (labels.length !== matrix.length) {\n      throw new Error(\n        'Confusion matrix and labels should have the same length',\n      );\n    }\n    this.labels = labels;\n    this.matrix = matrix;\n  }\n\n  /**\n   * Construct confusion matrix from the predicted and actual labels (classes). Be sure to provide the arguments in\n   * the correct order!\n   * @param {Array<any>} actual  - The predicted labels of the classification\n   * @param {Array<any>} predicted     - The actual labels of the classification. Has to be of same length as\n   *     predicted.\n   * @param {object} [options] - Additional options\n   * @param {Array<any>} [options.labels] - The list of labels that should be used. If not provided the distinct set\n   *     of labels present in predicted and actual is used. Labels are compared using the strict equality operator\n   *     '==='\n   * @return {ConfusionMatrix} - Confusion matrix\n   */\n  static fromLabels(actual, predicted, options = {}) {\n    if (predicted.length !== actual.length) {\n      throw new Error('predicted and actual must have the same length');\n    }\n    let distinctLabels;\n    if (options.labels) {\n      distinctLabels = new Set(options.labels);\n    } else {\n      distinctLabels = new Set([...actual, ...predicted]);\n    }\n    distinctLabels = Array.from(distinctLabels);\n    if (options.sort) {\n      distinctLabels.sort(options.sort);\n    }\n\n    // Create confusion matrix and fill with 0's\n    const matrix = Array.from({ length: distinctLabels.length });\n    for (let i = 0; i < matrix.length; i++) {\n      matrix[i] = new Array(matrix.length);\n      matrix[i].fill(0);\n    }\n\n    for (let i = 0; i < predicted.length; i++) {\n      const actualIdx = distinctLabels.indexOf(actual[i]);\n      const predictedIdx = distinctLabels.indexOf(predicted[i]);\n      if (actualIdx >= 0 && predictedIdx >= 0) {\n        matrix[actualIdx][predictedIdx]++;\n      }\n    }\n\n    return new ConfusionMatrix(matrix, distinctLabels);\n  }\n\n  /**\n   * Get the confusion matrix\n   * @return {Array<Array<number> >}\n   */\n  getMatrix() {\n    return this.matrix;\n  }\n\n  getLabels() {\n    return this.labels;\n  }\n\n  /**\n   * Get the total number of samples\n   * @return {number}\n   */\n  getTotalCount() {\n    let predicted = 0;\n    for (let i = 0; i < this.matrix.length; i++) {\n      for (let j = 0; j < this.matrix.length; j++) {\n        predicted += this.matrix[i][j];\n      }\n    }\n    return predicted;\n  }\n\n  /**\n   * Get the total number of true predictions\n   * @return {number}\n   */\n  getTrueCount() {\n    let count = 0;\n    for (let i = 0; i < this.matrix.length; i++) {\n      count += this.matrix[i][i];\n    }\n    return count;\n  }\n\n  /**\n   * Get the total number of false predictions.\n   * @return {number}\n   */\n  getFalseCount() {\n    return this.getTotalCount() - this.getTrueCount();\n  }\n\n  /**\n   * Get the number of true positive predictions.\n   * @param {any} label - The label that should be considered \"positive\"\n   * @return {number}\n   */\n  getTruePositiveCount(label) {\n    const index = this.getIndex(label);\n    return this.matrix[index][index];\n  }\n\n  /**\n   * Get the number of true negative predictions\n   * @param {any} label - The label that should be considered \"positive\"\n   * @return {number}\n   */\n  getTrueNegativeCount(label) {\n    const index = this.getIndex(label);\n    let count = 0;\n    for (let i = 0; i < this.matrix.length; i++) {\n      for (let j = 0; j < this.matrix.length; j++) {\n        if (i !== index && j !== index) {\n          count += this.matrix[i][j];\n        }\n      }\n    }\n    return count;\n  }\n\n  /**\n   * Get the number of false positive predictions.\n   * @param {any} label - The label that should be considered \"positive\"\n   * @return {number}\n   */\n  getFalsePositiveCount(label) {\n    const index = this.getIndex(label);\n    let count = 0;\n    for (let i = 0; i < this.matrix.length; i++) {\n      if (i !== index) {\n        count += this.matrix[i][index];\n      }\n    }\n    return count;\n  }\n\n  /**\n   * Get the number of false negative predictions.\n   * @param {any} label - The label that should be considered \"positive\"\n   * @return {number}\n   */\n  getFalseNegativeCount(label) {\n    const index = this.getIndex(label);\n    let count = 0;\n    for (let i = 0; i < this.matrix.length; i++) {\n      if (i !== index) {\n        count += this.matrix[index][i];\n      }\n    }\n    return count;\n  }\n\n  /**\n   * Get the number of real positive samples.\n   * @param {any} label - The label that should be considered \"positive\"\n   * @return {number}\n   */\n  getPositiveCount(label) {\n    return this.getTruePositiveCount(label) + this.getFalseNegativeCount(label);\n  }\n\n  /**\n   * Get the number of real negative samples.\n   * @param {any} label - The label that should be considered \"positive\"\n   * @return {number}\n   */\n  getNegativeCount(label) {\n    return this.getTrueNegativeCount(label) + this.getFalsePositiveCount(label);\n  }\n\n  /**\n   * Get the index in the confusion matrix that corresponds to the given label\n   * @param {any} label - The label to search for\n   * @throws if the label is not found\n   * @return {number}\n   */\n  getIndex(label) {\n    const index = this.labels.indexOf(label);\n    if (index === -1) throw new Error('The label does not exist');\n    return index;\n  }\n\n  /**\n   * Get the true positive rate a.k.a. sensitivity. Computes the ratio between the number of true positive predictions and the total number of positive samples.\n   * {@link https://en.wikipedia.org/wiki/Sensitivity_and_specificity}\n   * @param {any} label - The label that should be considered \"positive\"\n   * @return {number} - The true positive rate [0-1]\n   */\n  getTruePositiveRate(label) {\n    return this.getTruePositiveCount(label) / this.getPositiveCount(label);\n  }\n\n  /**\n   * Get the true negative rate a.k.a. specificity. Computes the ration between the number of true negative predictions and the total number of negative samples.\n   * {@link https://en.wikipedia.org/wiki/Sensitivity_and_specificity}\n   * @param {any} label - The label that should be considered \"positive\"\n   * @return {number}\n   */\n  getTrueNegativeRate(label) {\n    return this.getTrueNegativeCount(label) / this.getNegativeCount(label);\n  }\n\n  /**\n   * Get the positive predictive value a.k.a. precision. Computes TP / (TP + FP)\n   * {@link https://en.wikipedia.org/wiki/Positive_and_negative_predictive_values}\n   * @param {any} label - The label that should be considered \"positive\"\n   * @return {number}\n   */\n  getPositivePredictiveValue(label) {\n    const TP = this.getTruePositiveCount(label);\n    return TP / (TP + this.getFalsePositiveCount(label));\n  }\n\n  /**\n   * Negative predictive value\n   * {@link https://en.wikipedia.org/wiki/Positive_and_negative_predictive_values}\n   * @param {any} label - The label that should be considered \"positive\"\n   * @return {number}\n   */\n  getNegativePredictiveValue(label) {\n    const TN = this.getTrueNegativeCount(label);\n    return TN / (TN + this.getFalseNegativeCount(label));\n  }\n\n  /**\n   * False negative rate a.k.a. miss rate.\n   * {@link https://en.wikipedia.org/wiki/Type_I_and_type_II_errors#False_positive_and_false_negative_rates}\n   * @param {any} label - The label that should be considered \"positive\"\n   * @return {number}\n   */\n  getFalseNegativeRate(label) {\n    return 1 - this.getTruePositiveRate(label);\n  }\n\n  /**\n   * False positive rate a.k.a. fall-out rate.\n   * {@link https://en.wikipedia.org/wiki/Type_I_and_type_II_errors#False_positive_and_false_negative_rates}\n   * @param {any} label - The label that should be considered \"positive\"\n   * @return {number}\n   */\n  getFalsePositiveRate(label) {\n    return 1 - this.getTrueNegativeRate(label);\n  }\n\n  /**\n   * False discovery rate (FDR)\n   * {@link https://en.wikipedia.org/wiki/False_discovery_rate}\n   * @param {any} label - The label that should be considered \"positive\"\n   * @return {number}\n   */\n  getFalseDiscoveryRate(label) {\n    const FP = this.getFalsePositiveCount(label);\n    return FP / (FP + this.getTruePositiveCount(label));\n  }\n\n  /**\n   * False omission rate (FOR)\n   * @param {any} label - The label that should be considered \"positive\"\n   * @return {number}\n   */\n  getFalseOmissionRate(label) {\n    const FN = this.getFalseNegativeCount(label);\n    return FN / (FN + this.getTruePositiveCount(label));\n  }\n\n  /**\n   * F1 score\n   * {@link https://en.wikipedia.org/wiki/F1_score}\n   * @param {any} label - The label that should be considered \"positive\"\n   * @return {number}\n   */\n  getF1Score(label) {\n    const TP = this.getTruePositiveCount(label);\n    return (\n      (2 * TP) /\n      (2 * TP +\n        this.getFalsePositiveCount(label) +\n        this.getFalseNegativeCount(label))\n    );\n  }\n\n  /**\n   * Matthews correlation coefficient (MCC)\n   * {@link https://en.wikipedia.org/wiki/Matthews_correlation_coefficient}\n   * @param {any} label - The label that should be considered \"positive\"\n   * @return {number}\n   */\n  getMatthewsCorrelationCoefficient(label) {\n    const TP = this.getTruePositiveCount(label);\n    const TN = this.getTrueNegativeCount(label);\n    const FP = this.getFalsePositiveCount(label);\n    const FN = this.getFalseNegativeCount(label);\n    return (\n      (TP * TN - FP * FN) /\n      Math.sqrt((TP + FP) * (TP + FN) * (TN + FP) * (TN + FN))\n    );\n  }\n\n  /**\n   * Informedness\n   * {@link https://en.wikipedia.org/wiki/Youden%27s_J_statistic}\n   * @param {any} label - The label that should be considered \"positive\"\n   * @return {number}\n   */\n  getInformedness(label) {\n    return (\n      this.getTruePositiveRate(label) + this.getTrueNegativeRate(label) - 1\n    );\n  }\n\n  /**\n   * Markedness\n   * @param {any} label - The label that should be considered \"positive\"\n   * @return {number}\n   */\n  getMarkedness(label) {\n    return (\n      this.getPositivePredictiveValue(label) +\n      this.getNegativePredictiveValue(label) -\n      1\n    );\n  }\n\n  /**\n   * Get the confusion table.\n   * @param {any} label - The label that should be considered \"positive\"\n   * @return {Array<Array<number> >} - The 2x2 confusion table. [[TP, FN], [FP, TN]]\n   */\n  getConfusionTable(label) {\n    return [\n      [this.getTruePositiveCount(label), this.getFalseNegativeCount(label)],\n      [this.getFalsePositiveCount(label), this.getTrueNegativeCount(label)],\n    ];\n  }\n\n  /**\n   * Get total accuracy.\n   * @return {number} - The ratio between the number of true predictions and total number of classifications ([0-1])\n   */\n  getAccuracy() {\n    let correct = 0;\n    let incorrect = 0;\n    for (let i = 0; i < this.matrix.length; i++) {\n      for (let j = 0; j < this.matrix.length; j++) {\n        if (i === j) correct += this.matrix[i][j];\n        else incorrect += this.matrix[i][j];\n      }\n    }\n    return correct / (correct + incorrect);\n  }\n\n  /**\n   * Returns the element in the confusion matrix that corresponds to the given actual and predicted labels.\n   * @param {any} actual - The true label\n   * @param {any} predicted - The predicted label\n   * @return {number} - The element in the confusion matrix\n   */\n  getCount(actual, predicted) {\n    const actualIndex = this.getIndex(actual);\n    const predictedIndex = this.getIndex(predicted);\n    return this.matrix[actualIndex][predictedIndex];\n  }\n\n  /**\n   * Compute the general prediction accuracy\n   * @deprecated Use getAccuracy\n   * @return {number} - The prediction accuracy ([0-1]\n   */\n  get accuracy() {\n    return this.getAccuracy();\n  }\n\n  /**\n   * Compute the number of predicted observations\n   * @deprecated Use getTotalCount\n   * @return {number}\n   */\n  get total() {\n    return this.getTotalCount();\n  }\n}\n","'use strict';\nconst defaultOptions = {\n  mode: 'index'\n};\n\nmodule.exports = function *(M, N, options) {\n  options = Object.assign({}, defaultOptions, options);\n  var a = new Array(N);\n  var c = new Array(M);\n  var b = new Array(N);\n  var p = new Array(N + 2);\n  var x, y, z;\n\n  // init a and b\n  for (var i = 0; i < N; i++) {\n    a[i] = i;\n    if (i < N - M) b[i] = 0;\n    else b[i] = 1;\n  }\n\n  // init c\n  for (i = 0; i < M; i++) {\n    c[i] = N - M + i;\n  }\n\n  // init p\n  for (i = 0; i < p.length; i++) {\n    if (i === 0) p[i] = N + 1;\n    else if (i <= N - M) p[i] = 0;\n    else if (i <= N) p[i] = i - N + M;\n    else p[i] = -2;\n  }\n\n  function twiddle() {\n    var i, j, k;\n    j = 1;\n    while (p[j] <= 0) {\n      j++;\n    }\n    if (p[j - 1] === 0) {\n      for (i = j - 1; i !== 1; i--) {\n        p[i] = -1;\n      }\n      p[j] = 0;\n      x = z = 0;\n      p[1] = 1;\n      y = j - 1;\n    } else {\n      if (j > 1) {\n        p[j - 1] = 0;\n      }\n      do {\n        j++;\n      }\n      while (p[j] > 0);\n      k = j - 1;\n      i = j;\n      while (p[i] === 0) {\n        p[i++] = -1;\n      }\n      if (p[i] === -1) {\n        p[i] = p[k];\n        z = p[k] - 1;\n        x = i - 1;\n        y = k - 1;\n        p[k] = -1;\n      } else {\n        if (i === p[0]) {\n          return 0;\n        } else {\n          p[j] = p[i];\n          z = p[i] - 1;\n          p[i] = 0;\n          x = j - 1;\n          y = i - 1;\n        }\n      }\n    }\n    return 1;\n  }\n\n  if (options.mode === 'index') {\n    yield c.slice();\n    while (twiddle()) {\n      c[z] = a[x];\n      yield c.slice();\n    }\n  } else if (options.mode === 'mask') {\n    yield b.slice();\n    while (twiddle()) {\n      b[x] = 1;\n      b[y] = 0;\n      yield b.slice();\n    }\n  } else {\n    throw new Error('Invalid mode');\n  }\n};\n","/**\n * get folds indexes\n * @param {Array} features\n * @param {Number} k - number of folds, a\n */\nexport function getFolds(features, k = 5) {\n  let N = features.length;\n  let allIdx = new Array(N);\n  for (let i = 0; i < N; i++) {\n    allIdx[i] = i;\n  }\n\n  let l = Math.floor(N / k);\n  // create random k-folds\n  let current = [];\n  let folds = [];\n  while (allIdx.length) {\n    let randi = Math.floor(Math.random() * allIdx.length);\n    current.push(allIdx[randi]);\n    allIdx.splice(randi, 1);\n    if (current.length === l) {\n      folds.push(current);\n      current = [];\n    }\n  }\n  // we push the remaining to the last fold so that the total length is\n  // preserved. Otherwise the Q2 will fail.\n  if (current.length) current.forEach((e) => folds[k - 1].push(e));\n  folds = folds.slice(0, k);\n\n  let foldsIndex = folds.map((x, idx) => ({\n    testIndex: x,\n    trainIndex: [].concat(...folds.filter((el, idx2) => idx2 !== idx)),\n  }));\n  return foldsIndex;\n}\n","import ConfusionMatrix from 'ml-confusion-matrix';\nimport combinations from 'ml-combinations';\n\nimport { getFolds } from './getFolds.js';\n\nexport { sampleAClass } from './sampleAClass.js';\nexport { getFolds } from './getFolds.js';\n\n/**\n * Performs a leave-one-out cross-validation (LOO-CV) of the given samples. In LOO-CV, 1 observation is used as the\n * validation set while the rest is used as the training set. This is repeated once for each observation. LOO-CV is a\n * special case of LPO-CV. @see leavePout\n * @param {function} Classifier - The classifier's constructor to use for the cross validation. Expect ml-classifier\n *     api.\n * @param {Array} features - The features for all samples of the data-set\n * @param {Array} labels - The classification class of all samples of the data-set\n * @param {object} classifierOptions - The classifier options with which the classifier should be instantiated.\n * @return {ConfusionMatrix} - The cross-validation confusion matrix\n */\n\nexport function leaveOneOut(Classifier, features, labels, classifierOptions) {\n  if (typeof labels === 'function') {\n    let callback = labels;\n    labels = features;\n    features = Classifier;\n    return leavePOut(features, labels, 1, callback);\n  }\n  return leavePOut(Classifier, features, labels, classifierOptions, 1);\n}\n\n/**\n * Performs a leave-p-out cross-validation (LPO-CV) of the given samples. In LPO-CV, p observations are used as the\n * validation set while the rest is used as the training set. This is repeated as many times as there are possible\n * ways to combine p observations from the set (unordered without replacement). Be aware that for relatively small\n * data-set size this can require a very large number of training and testing to do!\n * @param {function} Classifier - The classifier's constructor to use for the cross validation. Expect ml-classifier\n *     api.\n * @param {Array} features - The features for all samples of the data-set\n * @param {Array} labels - The classification class of all samples of the data-set\n * @param {object} classifierOptions - The classifier options with which the classifier should be instantiated.\n * @param {number} p - The size of the validation sub-samples' set\n * @return {ConfusionMatrix} - The cross-validation confusion matrix\n */\nexport function leavePOut(Classifier, features, labels, classifierOptions, p) {\n  let callback;\n  if (typeof classifierOptions === 'function') {\n    callback = classifierOptions;\n    p = labels;\n    labels = features;\n    features = Classifier;\n  }\n  check(features, labels);\n  const distinct = getDistinct(labels);\n  const confusionMatrix = initMatrix(distinct.length, distinct.length);\n\n  let N = features.length;\n  let gen = combinations(p, N);\n  let allIdx = new Array(N);\n  for (let i = 0; i < N; i++) {\n    allIdx[i] = i;\n  }\n  for (const testIdx of gen) {\n    let trainIdx = allIdx.slice();\n\n    for (let i = testIdx.length - 1; i >= 0; i--) {\n      trainIdx.splice(testIdx[i], 1);\n    }\n\n    if (callback) {\n      validateWithCallback(\n        features,\n        labels,\n        testIdx,\n        trainIdx,\n        confusionMatrix,\n        distinct,\n        callback,\n      );\n    } else {\n      validate(\n        Classifier,\n        features,\n        labels,\n        classifierOptions,\n        testIdx,\n        trainIdx,\n        confusionMatrix,\n        distinct,\n      );\n    }\n  }\n\n  return new ConfusionMatrix(confusionMatrix, distinct);\n}\n\n/**\n * Performs k-fold cross-validation (KF-CV). KF-CV separates the data-set into k random equally sized partitions, and\n * uses each as a validation set, with all other partitions used in the training set. Observations left over from if k\n * does not divide the number of observations are left out of the cross-validation process.\n * @param {function} Classifier - The classifier's to use for the cross validation. Expect ml-classifier api.\n * @param {Array} features - The features for all samples of the data-set\n * @param {Array} labels - The classification class of all samples of the data-set\n * @param {object} classifierOptions - The classifier options with which the classifier should be instantiated.\n * @param {number} k - The number of partitions to create\n * @return {ConfusionMatrix} - The cross-validation confusion matrix\n */\nexport function kFold(Classifier, features, labels, classifierOptions, k) {\n  let callback;\n  if (typeof classifierOptions === 'function') {\n    callback = classifierOptions;\n    k = labels;\n    labels = features;\n    features = Classifier;\n  }\n  check(features, labels);\n  const distinct = getDistinct(labels);\n  const confusionMatrix = initMatrix(distinct.length, distinct.length);\n\n  let folds = getFolds(features, k);\n\n  for (let i = 0; i < folds.length; i++) {\n    let testIdx = folds[i].testIndex;\n    let trainIdx = folds[i].trainIndex;\n\n    if (callback) {\n      validateWithCallback(\n        features,\n        labels,\n        testIdx,\n        trainIdx,\n        confusionMatrix,\n        distinct,\n        callback,\n      );\n    } else {\n      validate(\n        Classifier,\n        features,\n        labels,\n        classifierOptions,\n        testIdx,\n        trainIdx,\n        confusionMatrix,\n        distinct,\n      );\n    }\n  }\n\n  return new ConfusionMatrix(confusionMatrix, distinct);\n}\n\nfunction check(features, labels) {\n  if (features.length !== labels.length) {\n    throw new Error('features and labels should have the same length');\n  }\n}\n\nfunction initMatrix(rows, columns) {\n  return new Array(rows).fill(0).map(() => new Array(columns).fill(0));\n}\n\nfunction getDistinct(arr) {\n  let s = new Set();\n  for (let i = 0; i < arr.length; i++) {\n    s.add(arr[i]);\n  }\n  return Array.from(s);\n}\n\nfunction validate(\n  Classifier,\n  features,\n  labels,\n  classifierOptions,\n  testIdx,\n  trainIdx,\n  confusionMatrix,\n  distinct,\n) {\n  const { testFeatures, trainFeatures, testLabels, trainLabels } = getTrainTest(\n    features,\n    labels,\n    testIdx,\n    trainIdx,\n  );\n\n  let classifier;\n  if (Classifier.prototype.train) {\n    classifier = new Classifier(classifierOptions);\n    classifier.train(trainFeatures, trainLabels);\n  } else {\n    classifier = new Classifier(trainFeatures, trainLabels, classifierOptions);\n  }\n\n  let predictedLabels = classifier.predict(testFeatures);\n  updateConfusionMatrix(confusionMatrix, testLabels, predictedLabels, distinct);\n}\n\nfunction validateWithCallback(\n  features,\n  labels,\n  testIdx,\n  trainIdx,\n  confusionMatrix,\n  distinct,\n  callback,\n) {\n  const { testFeatures, trainFeatures, testLabels, trainLabels } = getTrainTest(\n    features,\n    labels,\n    testIdx,\n    trainIdx,\n  );\n  const predictedLabels = callback(trainFeatures, trainLabels, testFeatures);\n  updateConfusionMatrix(confusionMatrix, testLabels, predictedLabels, distinct);\n}\n\nfunction updateConfusionMatrix(\n  confusionMatrix,\n  testLabels,\n  predictedLabels,\n  distinct,\n) {\n  for (let i = 0; i < predictedLabels.length; i++) {\n    const actualIdx = distinct.indexOf(testLabels[i]);\n    const predictedIdx = distinct.indexOf(predictedLabels[i]);\n    if (actualIdx < 0 || predictedIdx < 0) {\n      // eslint-disable-next-line no-console\n      console.warn(`ignore unknown predicted label ${predictedLabels[i]}`);\n    }\n    confusionMatrix[actualIdx][predictedIdx]++;\n  }\n}\n\nfunction getTrainTest(features, labels, testIdx, trainIdx) {\n  return {\n    testFeatures: testIdx.map(function(index) {\n      return features[index];\n    }),\n    trainFeatures: trainIdx.map(function(index) {\n      return features[index];\n    }),\n    testLabels: testIdx.map(function(index) {\n      return labels[index];\n    }),\n    trainLabels: trainIdx.map(function(index) {\n      return labels[index];\n    }),\n  };\n}\n","/**\n * A function to sample a dataset maintaining classes equilibrated\n * @param {Array} classVector - an array containing class or group information\n * @param {Number} fraction - a fraction of the class to sample\n * @return {Object} - an object with indexes\n */\n\nexport function sampleAClass(classVector, fraction) {\n  // sort the vector\n  let classVectorSorted = JSON.parse(JSON.stringify(classVector));\n  let result = Array.from(Array(classVectorSorted.length).keys()).sort((a, b) =>\n    classVectorSorted[a] < classVectorSorted[b]\n      ? -1\n      : (classVectorSorted[b] < classVectorSorted[a]) | 0,\n  );\n  classVectorSorted.sort((a, b) => (a < b ? -1 : (b < a) | 0));\n\n  // counts the class elements\n  let counts = {};\n  classVectorSorted.forEach((x) => (counts[x] = (counts[x] || 0) + 1));\n\n  // pick a few per class\n  let indexOfSelected = [];\n\n  Object.keys(counts).forEach((e, i) => {\n    let shift = [];\n    Object.values(counts).reduce((a, c, i) => (shift[i] = a + c), 0);\n\n    let arr = [...Array(counts[e]).keys()];\n\n    let r = [];\n    for (let i = 0; i < Math.floor(counts[e] * fraction); i++) {\n      let n = arr[Math.floor(Math.random() * arr.length)];\n      r.push(n);\n      let ind = arr.indexOf(n);\n      arr.splice(ind, 1);\n    }\n\n    i == 0\n      ? (indexOfSelected = indexOfSelected.concat(r))\n      : (indexOfSelected = indexOfSelected.concat(\n          r.map((x) => x + shift[i - 1]),\n        ));\n  });\n\n  // sort back the index\n  let trainIndex = [];\n  indexOfSelected.forEach((e) => trainIndex.push(result[e]));\n\n  let testIndex = [];\n  let mask = [];\n  classVector.forEach((el, idx) => {\n    if (trainIndex.includes(idx)) {\n      mask.push(true);\n    } else {\n      mask.push(false);\n      testIndex.push(idx);\n    }\n  });\n  return { trainIndex, testIndex, mask };\n}\n"],"names":["ConfusionMatrix","constructor","matrix","labels","length","Error","actual","predicted","distinctLabels","options","Set","Array","from","sort","i","fill","actualIdx","indexOf","predictedIdx","getMatrix","this","getLabels","getTotalCount","j","getTrueCount","count","getFalseCount","getTruePositiveCount","label","index","getIndex","getTrueNegativeCount","getFalsePositiveCount","getFalseNegativeCount","getPositiveCount","getNegativeCount","getTruePositiveRate","getTrueNegativeRate","getPositivePredictiveValue","TP","getNegativePredictiveValue","TN","getFalseNegativeRate","getFalsePositiveRate","getFalseDiscoveryRate","FP","getFalseOmissionRate","FN","getF1Score","getMatthewsCorrelationCoefficient","Math","sqrt","getInformedness","getMarkedness","getConfusionTable","getAccuracy","correct","incorrect","getCount","actualIndex","predictedIndex","defaultOptions","mode","M","N","Object","assign","x","y","z","a","c","b","p","twiddle","k","slice","getFolds","features","allIdx","l","floor","current","folds","randi","random","push","splice","forEach","e","map","idx","testIndex","trainIndex","concat","filter","el","idx2","leavePOut","Classifier","classifierOptions","callback","check","distinct","getDistinct","confusionMatrix","initMatrix","gen","combinations","testIdx","trainIdx","validateWithCallback","validate","rows","columns","arr","s","add","testFeatures","trainFeatures","testLabels","trainLabels","getTrainTest","classifier","prototype","train","updateConfusionMatrix","predict","predictedLabels","console","warn","classVector","fraction","classVectorSorted","JSON","parse","stringify","result","keys","counts","indexOfSelected","shift","values","reduce","r","n","ind","mask","includes"],"mappings":"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"}